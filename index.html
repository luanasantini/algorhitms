<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Estruturas de Dados & Algoritmos</title>
    <link rel="stylesheet" href="styles.css">
    <link
        href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&family=Quicksand:wght@300;400;500&display=swap"
        rel="stylesheet">
</head>

<body>
    <header>
        <h1>Estruturas de Dados & Complexidade de Algoritmos </h1>
        <p class="subtitle">Um guia sobre conceitos de programa√ß√£o</p>
    </header>

    <nav>
        <ul>
            <li><a href="#vetores">Vetores</a></li>
            <li><a href="#matrizes">Matrizes</a></li>
            <li><a href="#ponteiros">Ponteiros</a></li>
            <li><a href="#recursao">Fun√ß√µes Recursivas</a></li>
            <li><a href="#bigo">Nota√ß√£o Big O</a></li>
        </ul>
    </nav>

    <main>

        <section id="Vetores" class="topic">
            <h2>‚ú® Vetores</h2>
            <p>Vetores s√£o estruturas de dados que armazenam uma sequ√™ncia de elementos do mesmo tipo em posi√ß√µes
                consecutivas de mem√≥ria.
                <br>
            <div class="split-content">
                <div class="content-left">
                    <h3 class="content-title">Caracter√≠sticas Principais:</h3>
                    - Estrutura de dados mais b√°sica e fundamental na programa√ß√£o<br>
                    - Cada elemento √© acessado por um √≠ndice (come√ßando do zero)<br>
                    - O tamanho do vetor √© fixo (em linguagens como C) ou din√¢mico (em Python)<br>
                    - Os elementos s√£o armazenados lado a lado na mem√≥ria, o que permite acesso r√°pido

                </div>
                <div class="content-right">
                    <h3 class="content-title">Principais Usos:</h3>
                    - Implementar listas e armazenar dados em sequ√™ncia (como notas, nomes, temperaturas) <br>
                    - Processamento de dados em lote<br>
                    - Manipula√ß√£o de conjuntos de valores relacionados<br>
                    - Realizar buscas, ordena√ß√µes e opera√ß√µes matem√°ticas<br>
                    - Base para estruturas mais complexas como matrizes, filas e pilhas

                </div>
            </div>
            </p>

            <div class="code-examples">
                <div class="code-block">
                    <h3>Exemplo em C</h3>
                    <pre><code>
#include &lt;stdio.h>

int main() {
    float notas[5] = {10, 8.5, 9.5, 9, 10};
    
    printf("Minhas notas desse semestre foram:\n");
    for(int i = 0; i < 5; i++) {
        printf("%.1f, ", notas[i]);
    }
    return 0;
}
                    </code></pre>
                </div>

                <div class="code-block">
                    <h3>Exemplo em Python</h3>
                    <pre><code>
notas = [10, 8.5, 9.5, 9, 10]

print("Minhas notas desse semestre foram:")
for elemento in notas:
    print(elemento, end=", ")
                    </code></pre>
                </div>
            </div>
        </section>

        <section id="matrizes" class="topic">
            <h2>‚ú® Matrizes</h2>
            <p>Uma matriz √© uma estrutura de dados que representa uma cole√ß√£o bidimensional de elementos ‚Äî ou seja, uma
                tabela com linhas e colunas. Ela √© como um vetor de vetores: cada linha √© um vetor, e cada elemento
                dentro da linha √© acessado por um √≠ndice de coluna.<br>
            <div class="split-content">
                <div class="content-left">
                    <h3 class="content-title">Caracter√≠sticas Principais:</h3>
                    - Armazena dados do mesmo tipo<br>
                    - Os elementos s√£o acessados por dois √≠ndices: linha e coluna<br>
                    - Pode ser fixa (como em C) ou din√¢mica (como em Python)<br>
                    - Organiza√ß√£o bidimensional dos dados<br>
                    - O armazenamento em mem√≥ria cont√≠gua depende da linguagem<br>
                </div>
                <div class="content-right">
                    <h3 class="content-title">Principais Usos:</h3>
                    - Processamento de imagens digitais (matrizes de pixel)<br>
                    - Representa√ß√£o de grades e mapas<br>
                    - Sitemas matem√°ticos e √°lgebra linear<br>
                    - Jogos (tabuleiros, mapas de tile, ambienta√ß√µes 3D)<br>
                    - Representa√ß√£o e an√°lise de dados tabulares (planilhas, banco de dados)

                </div>
            </div>
            </p>

            <div class="code-examples">
                <div class="code-block">
                    <h3>Exemplo em C</h3>
                    <pre><code>
#include &lt;stdio.h>

int main() {
    float notas[3][3] = {
        {8.5, 10, 9},  // Semestre 1
        {9, 8.5, 9},  // Semestre 2
        {9.5, 10, 8.5}   // Semestre 3
    };
    
    printf("Minhas notas nos √∫ltimos 3 semestres foram:\n");  
    
    for(int i = 0; i < 3; i++) {
        float soma = 0;
        for(int j = 0; j < 3; j++) {
            soma += notas[i][j];
        }
        float media = soma / 3;
        printf("Semestre %d - M√©dia: %.2f\n", i + 1, media);
    }
    return 0;
}
                    </code></pre>
                </div>

                <div class="code-block">
                    <h3>Exemplo em Python</h3>
                    <pre><code>
notas = [
    [8.5, 10, 9],     # Semestre 1
    [9, 8.5, 9],      # Semestre 2
    [9.5, 10, 8.5]    # Semestre 3
]

print("Minhas notas nos √∫ltimos 3 semestres foram:")

for i in range(3):
    soma = 0
    for j in range(3):
        soma += notas[i][j]
    media = soma / 3
    print(f"Semestre {i + 1} - M√©dia: {media:.2f}")
                    </code></pre>
                </div>
            </div>
        </section>

        <section id="ponteiros" class="topic">
            <h2>‚ú® Ponteiros</h2>
            <p>Um ponteiro √© uma vari√°vel que armazena o endere√ßo de mem√≥ria de outra vari√°vel. Ou seja, em vez de
                guardar um valor diretamente, ele aponta para onde esse valor est√° guardado na mem√≥ria.
                <br>
            <div class="split-content">
                <div class="content-left">
                    <h3 class="content-title">Caracter√≠sticas Principais:</h3>
                    - Cada ponteiro aponta para um tipo especifico (ex: int*, char*)<br>
                    - Permitem acessar indiretamente ou modificar o valor da vari√°vel apontada<br>
                    - Podem ser incrementados/decrementados (apontar para o pr√≥ximo elemento ou para o anterior) <br>
                    - Podem ser nulos (NULL em C)<br>
                    - Fundamentais em C/C++
                </div>
                <div class="content-right">
                    <h3 class="content-title">Principais Usos:</h3>
                    - Aloca√ß√£o din√¢mica de mem√≥ria (ex: criar vetores ou matrizes em tempo de execu√ß√£o).<br>
                    - Passagem por refer√™ncia em fun√ß√µes (evita c√≥pia de dados grandes)<br>
                    - Cria√ß√£o de estruturas de dados (listas, pilhas, filas, arvores)<br>
                    - Manipula√ß√£o eficiente de arrays e strings em baixo n√≠vel<br>
                    - Gerenciamento de recursos de hardware (ex: endere√ßos fisicos)
                </div>
            </div>
            </p>

            <div class="code-examples">
                <div class="code-block">
                    <h3>Exemplo em C</h3>
                    <pre><code>
#include &lt;stdio.h>

int main() {
    int numero = 13;
    int *ponteiro = &amp;numero;

    
    printf("Valor: %d\n", numero);
    printf("Endere√ßo: %p\n", ponteiro);
    printf("Valor via ponteiro: %d\n", *ponteiro);
    
    return 0;
}
                    </code></pre>
                </div>

                <div class="code-block">
                    <h3>Exemplo em Python</h3>
                    <pre><code>
numero = 13
referencia = numero

print(f"Valor: {numero}")
print(f"ID do objeto: {id(numero)}")
print(f"Valor via refer√™ncia: {referencia}")<br>
                    </code></pre>

                    <br>Obs.: Python n√£o tem ponteiros diretos, por√©m a linguagem trabalha com refer√™ncias de objetos, o
                    que permite simular o comportamento de ponteiros em muitos casos (se voc√™ modifica o conte√∫do, todas
                    as vari√°veis que apontam para o mesmo objeto ver√£o a mudan√ßa).
                </div>
            </div>
        </section>

        <section id="recursao" class="topic">
            <h2>‚ú® Fun√ß√µes Recursivas</h2>
            <p>Uma fun√ß√£o recursiva √© uma fun√ß√£o que chama a si mesma dentro de sua pr√≥pria defini√ß√£o, com o objetivo de
                resolver um problema dividindo-o em partes menores.
                <br>
            <div class="split-content">
                <div class="content-left">
                    <h3 class="content-title">Caracter√≠sticas Principais:</h3>
                    - Fun√ß√£o que chama a si mesma com um novo par√¢metro<br>
                    - Precisa de um caso base (condi√ß√£o que interrompe a recurs√£o, evitando chamadas infinitas)<br>
                    - Cada chamada trata uma parte menor do problema original<br>
                    - Pode ter m√∫ltiplas chamadas recursivas<br>
                </div>
                <div class="content-right">
                    <h3 class="content-title">Principais Usos:</h3>
                    - Algoritmos de busca como quicksort e mergesort<br>
                    - C√°lculo de sequ√™ncias matem√°ticas (fatorial, fibonacci, exponencia√ß√£o)<br>
                    - Percurso em estruturas hier√°rquicas (√°rvores, grafos, listas ligadas)<br>
                    - Problemas combinat√≥rios como permuta√µes, combina√ß√µes, backtracking

                </div>
            </div>
            </p>

            <div class="recursion-theory">
                <h3>‚òÖ 3 leis b√°sicas da recurs√£o</h3>
                <ol>
                    <li>Um algoritmo recursivo deve ter um caso b√°sico (caso base) que determina quando a recurs√£o deve
                        parar</li>
                    <li>Um algoritmo recursivo deve mudar seu estado e se aproximar do caso b√°sico a cada chamada
                        recursiva</li>
                    <li>Um algoritmo recursivo deve chamar a si mesmo recursivamente</li>
                </ol>

                <h3>‚òÖ Classifica√ß√£o das fun√ß√µes recursivas</h3>
                <ul>
                    <li><strong>Recurs√£o Direta:</strong> A fun√ß√£o chama ela mesma</li>
                    <li><strong>Recurs√£o Indireta:</strong> A primeira fun√ß√£o chama a segunda fun√ß√£o, que chama
                        novamente a primeira fun√ß√£o</li>
                    <li><strong>Recurs√£o Linear:</strong> Apenas uma chamada recursiva por execu√ß√£o</li>
                    <li><strong>Recurs√£o M√∫ltipla:</strong> Faz mais de uma chamada recursiva por execu√ß√£o</li>
                    <li><strong>Recurs√£o Aninhada:</strong> A chamada recursiva est√° dentro de outra chamada recursiva
                    </li>
                    <li><strong>Recurs√£o Mutual:</strong> Duas ou mais fun√ß√µes se chamam mutuamente</li>
                </ul>

                <p class="note">üå∏ Observa√ß√£o: A recurs√£o usa uma estrutura de dados embutida. Cada vez que a fun√ß√£o √©
                    chamada, uma nova c√≥pia das vari√°veis locais e dos par√¢metros √© criada separadamente.</p>
            </div>

            <div class="code-examples">
                <div class="code-block">
                    <h3>Exemplo em C</h3>
                    <pre><code>
#include &lt;stdio.h>

int fatorial(int n) {
    if(n == 0 || n == 1)
        return 1;
    else
        return n * fatorial(n - 1);
}

int main() {
    printf("%d\n", fatorial(5));
    return 0;
}
                    </code></pre>
                </div>

                <div class="code-block">
                    <h3>Exemplo em Python</h3>
                    <pre><code>
def fatorial(n):
    if n == 0 or n == 1:
        return 1
    else:
        return n * fatorial(n - 1)

print(fatorial(5))
                    </code></pre>
                </div>
            </div>
        </section>

        <section id="bigo" class="topic">
            <h2>‚ú® Nota√ß√£o Big O</h2>
            <p>A nota√ß√£o Big O √© uma fun√ß√£o matematica utilizada na computa√ß√£o para analisar o desempenho ou
                complexidade de um algoritmo de acordo com o tamanho da entrada. Essa nota√ß√£o mede o desempenho do
                limite superior. Quanto mais aumentar a complexidade de um algoritmo, menos ele ser√° eficiente. </p>
            <br>
            <div class="complexity-types">
                <div class="complexity">
                    <h3>üå∏ O(1) - Tempo Constante</h3>
                    <p>O algoritmo sempre executa no mesmo tempo, independente do tamanho da entrada, ou seja, n√£o h√°
                        depend√™ncia no tamanho da entrada, e a fun√ß√£o exigir√° apenas uma etapa de execu√ß√£o.<br><br>
                        Exemplo: Acessar <strong>um elemento</strong> em um array por √≠ndice (independente do tamanho do
                        array).</p>
                </div>
                <div class="complexity">
                    <h3>üå∏ O(log n) - Tempo Logar√≠tmico</h3>
                    <p>O tempo de execu√ß√£o aumenta logaritmicamente com o tamanho da entrada. Isso ocorre em fun√ß√µes que
                        a quantidade dos dados de entrada diminui a cada etapa - ou seja, o n√∫mero de opera√ß√µes n√£o √© o
                        mesmo que o tamanho da entrada.<br><br>
                        Exemplo: Busca bin√°ria em um array ordenado (a cada itera√ß√£o, o array √© dividido em 2).</p>
                </div>
                <div class="complexity">
                    <h3>üå∏ O(n) - Tempo Linear</h3>
                    <p>O tempo de execu√ß√£o aumenta linearmente com o tamanho da entrada. O n especifica o n√∫mero de
                        vezes que a fun√ß√£o ser√° executada.<br><br>
                        Exemplo: <strong>Percorrer</strong> todos os elementos de um array. Se o array tiver 500 itens,
                        o tempo ser√° O(500)</p>
                </div>



                <div class="complexity">
                    <h3>üå∏ O(n log n) - Tempo Log-Linear</h3>
                    <p>O tempo de execu√ß√£o aumenta logaritmicamente de acordo com o processamento de cada elemento. O
                        tempo cresce mais r√°pido que logaritmico, mas bem mais lento que quadr√°tico.<br><br>
                        Exemplo: Algoritmos eficientes de ordena√ß√£o como Merge Sort, Quick Sort.</p>
                </div>

                <div class="complexity">
                    <h3>üå∏ O(n¬≤) - Tempo Quadr√°tico</h3>
                    <p>O tempo de execu√ß√£o cresce proporcionamentel ao quadrado do tamanho da entrada (o algoritmo pode
                        fazer at√© n x n opera√ß√µes).<br><br>
                        Exemplo: Algoritmos que comparam cada elemento com todos os outros, como Bubble Sort e loops
                        aninhados simples.</p>
                </div>

                <div class="complexity">
                    <h3>üå∏ O(n¬≥) - Tempo C√∫bico</h3>
                    <p>O tempo de execu√ß√£o cresce proporcionamentel ao cubo do tamanho da entrada (o algoritmo pode
                        fazer at√© n x n x n opera√ß√µes)<br><br>
                        Exemplo: Multiplica√ß√£o ing√™nua de matrizes, 3 n√≠veis de loops aninhados.</p>
                </div>

                <div class="complexity">
                    <h3>üå∏ O(2‚Åø) - Tempo Exponencial</h3>
                    <p>O tempo de execu√ß√£o <strong>dobra</strong> toda vez que o conjunto de dados de entrada √©
                        adicionado.<br><br>
                        Exemplo: Algoritmo que precisa testar todas as combina√ß√µes poss√≠veis, como problemas
                        combinat√≥rios complexos, algoritmos de for√ßa bruta, criptografia e quebra de senhas</p>
                </div>

                <div class="complexity">
                    <h3>üå∏ O(n!) - Tempo Fatorial</h3>
                    <p>O tempo de execu√ß√£o cresce de forma fatorial com o tamanho da entrada. Cada novo elemento
                        multiplica o tempo por um n√∫mero maior.
                        <br><br>
                        Exemplo: Gerar todas as permuta√ß√µes poss√≠veis de uma lista, alguns algoritmos de intelig√™ncia
                        artifical
                    </p>
                </div>
            </div>
            <div class="code-examples">
                <div class="code-block">
                    <img src="https://blogger.googleusercontent.com/img/a/AVvXsEgczq_x8g9BOszSWYUdL-tUE3Rf3yIgH3SQVpCFWswhYCWYhEobXYHSUNyDtTabFUwbLGhruFTHLkQHZoPBM1eZ5-vjobTrbjAba9ASYuqPNt_2MyOhGzKX60dvh1dwsYGAjqiMh4Ji4kk6gD8RjAozhj5Vs8AJzSrj6w_qzYiknwezrYJwknHI6rSbpw=w1200-h630-p-k-no-nu"
                        alt="Descri√ß√£o da imagem">

                </div>

            </div>
        </section>

        </section>
    </main>

    <footer>
        <p>üå∏ Luana Santini: Sistemas de Informa√ß√£o - Est√°cio Florian√≥polis - Matr√≠cula 202308416251üå∏</p>
    </footer>
</body>

</html>